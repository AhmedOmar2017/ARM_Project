/*******************************************************************************
*====================== Auther: Ahmed Omar  ====================================
=======================   Date:21/7/2022    ====================================
============   function responsible for configration    ========================
=====================  general perpose Timer ===================================
*******************************************************************************/
#include "TIMER.h"



/*==========================================================================
 *                                disable
 *==========================================================================*/
void Disable_Timer(uint32_t adr)
{
    hardWare_reading(adr+R_TIMER_CTRLOffset) &= ~(1<<0);
}

/*==========================================================================
 *                                enable
 *==========================================================================*/
void Enble_Timer(uint32_t adr)
{
    hardWare_reading(adr+R_TIMER_CTRLOffset) |= (1<<0);
}

/*==========================================================================
 *                                configration 
 *==========================================================================*/
void Cnfig_Timer(uint32_t adr, uint8_t val)
{
    hardWare_reading(adr+R_TIMER_CFGOffset) = val;
}


/*==========================================================================
 *                                mode 
 *==========================================================================*/
void Mod_Timer(uint32_t adr, uint8_t val)
{
    hardWare_reading(adr+R_TIMER_A_MODOffset) = val;
}

/*==========================================================================
 *                                prescale 
 *==========================================================================*/
void Prsc_Timer(uint32_t adr, uint8_t val)
{
    hardWare_reading(adr+R_TIMER_A_PRSCOffset) = val-1;
}

/*==========================================================================
 *                                preload
 *==========================================================================*/
void Prload_Timer(uint32_t adr, uint8_t val)
{
    hardWare_reading(adr+R_TIMER_A_ILOffset) = val-1;
}



/*==========================================================================
 *                                clear
 *==========================================================================*/
void Int_Clr_Timer(uint32_t adr, uint8_t val)
{
    hardWare_reading(adr+R_TIMER_ICOffset) = (val<<0);
}


/*==========================================================================
 *                                interrupt mask
 *==========================================================================*/
void Int_Msk_Timer(uint32_t adr, uint8_t val)
{
    hardWare_reading(adr+R_TIMER_IMOffset) = (val<<0);
}


/*==========================================================================
 *                           interrupt mask Status
 *==========================================================================*/
volatile uint32_t Int_Msk_Stat_Timer(uint32_t adr)
{
    return hardWare_reading(adr+R_TIMER_IMSOffset);
}

uint32_t Set_value_Blinking(uint32_t adr, uint8_t O_val, uint8_t F_val, uint32_t Ref)
{
    
    Ref++;
    if(Ref <= (O_val*1000))
    {
        Wr_Pin(adr,2,HIGH);
    }
    else if (Ref > (O_val * 1000) && Ref <= ((F_val + O_val) * 1000))
    {
            Wr_Pin(adr,2,LOW);
    }
    else
    {
            Ref = 0;
    }

    return Ref;
			
}		

